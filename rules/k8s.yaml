version: 1
symbols:
  - name: k8s.resource.name
    description: "Resource Name (Kind + Namespace + Name)"
    keyTemplate: "{{ .kind }}/{{ .namespace }}/{{ .name }}"
    definitions:
      - kinds: ["Deployment", "StatefulSet", "DaemonSet", "Job", "CronJob", "Pod"]
        path: "metadata.name"
      - kinds: ["Service", "Ingress", "ConfigMap", "Secret", "PersistentVolumeClaim", "Namespace", "ServiceAccount", "Role", "ClusterRole"]
        path: "metadata.name"

  - name: k8s.label
    description: "Label (Namespace + Key + Value)"
    keyTemplate: "label/{{ .namespace }}/{{ .key }}={{ .value }}"
    definitions:
      - kinds: ["Deployment", "StatefulSet", "DaemonSet", "Job", "Pod", "Service"]
        path: "metadata.labels"

references:
  - name: service.selector.label
    symbol: k8s.label
    targetKind: Pod
    match:
      kinds: ["Service"]
      path: "spec.selector"

  - name: ingress.backend.service
    symbol: k8s.resource.name
    targetKind: Service
    match:
      kinds: ["Ingress"]
      path: "spec.rules[].http.paths[].backend.service.name"
    # Implicitly we know this looks for a Service, but the symbol is generic.
    # We might need to handle this ambiguity or just search all.

  - name: deployment.configmap-ref
    symbol: k8s.resource.name
    targetKind: ConfigMap
    match:
      kinds: ["Deployment"]
      path: "spec.template.spec.volumes[].configMap.name"
    # Looks for ConfigMap

  - name: namespace.ref
    symbol: k8s.resource.name
    targetKind: Namespace
    match:
      kinds: ["*"] # All resources can have namespace ref in metadata? No, usually it's metadata.namespace
      path: "metadata.namespace"
    # Looks for Namespace

  - name: workload.env.secret
    symbol: k8s.resource.name
    targetKind: Secret
    match:
      kinds: ["Deployment", "StatefulSet", "DaemonSet", "Job"]
      path: "spec.template.spec.containers[].env[].valueFrom.secretKeyRef.name"

  - name: workload.envfrom.secret
    symbol: k8s.resource.name
    targetKind: Secret
    match:
      kinds: ["Deployment", "StatefulSet", "DaemonSet", "Job"]
      path: "spec.template.spec.containers[].envFrom[].secretRef.name"

  - name: workload.volume.secret
    symbol: k8s.resource.name
    targetKind: Secret
    match:
      kinds: ["Deployment", "StatefulSet", "DaemonSet", "Job"]
      path: "spec.template.spec.volumes[].secret.secretName"

  - name: workload.imagePullSecrets
    symbol: k8s.resource.name
    targetKind: Secret
    match:
      kinds: ["Deployment", "StatefulSet", "DaemonSet", "Job"]
      path: "spec.template.spec.imagePullSecrets[].name"

  - name: workload.env.configmap
    symbol: k8s.resource.name
    targetKind: ConfigMap
    match:
      kinds: ["Deployment", "StatefulSet", "DaemonSet", "Job"]
      path: "spec.template.spec.containers[].env[].valueFrom.configMapKeyRef.name"

  - name: workload.envfrom.configmap
    symbol: k8s.resource.name
    targetKind: ConfigMap
    match:
      kinds: ["Deployment", "StatefulSet", "DaemonSet", "Job"]
      path: "spec.template.spec.containers[].envFrom[].configMapRef.name"

  - name: workload.serviceaccount
    symbol: k8s.resource.name
    targetKind: ServiceAccount
    match:
      kinds: ["Deployment", "StatefulSet", "DaemonSet", "Job"]
      path: "spec.template.spec.serviceAccountName"

  - name: workload.volume.pvc
    symbol: k8s.resource.name
    targetKind: PersistentVolumeClaim
    match:
      kinds: ["Deployment", "StatefulSet", "DaemonSet", "Job"]
      path: "spec.template.spec.volumes[].persistentVolumeClaim.claimName"
